#!/bin/sh -X # no runnable script, just for editors
# set -eu is assumed.
# (Note that in ALT /bin/sh is a bash with a few features turned off.)
# (TODO: make sure that ALT's /bin/sh is enough;
# use the lightweight /bin/sh in the actual test scripts.)

# Under set -x, don't mess the trace with other commands' output (possibly
# redirected), rather send it directly to the global stderr.
exec 5>&2
BASH_XTRACEFD=5

EXIT_CODE=0

# During the most lifetime of the script (until the exiting traps), this var is
# just used to count the failed tests. Better do this via a dedicated function:
XFAILED=0
one_more_failure() {
	if [ "$APT_TEST_XFAIL" = '' ]; then
		EXIT_CODE=$((EXIT_CODE+1))
	else
		XFAILED=$((XFAILED+1))
	fi
}

# we all like colorful messages
if [ "$MSGCOLOR" != 'NO' ]; then
	if [ ! -t 1 ]; then # but check that we output to a terminal
		export MSGCOLOR='NO'
	fi
fi

CERROR=
CWARNING=
CMSG=
CINFO=
CDEBUG=
CNORMAL=
CDONE=
CPASS=
CFAIL=
CCMD=

if [ "$MSGCOLOR" != 'NO' ]; then
	CERROR="\033[1;31m" # red
	CWARNING="\033[1;33m" # yellow
	CMSG="\033[1;32m" # green
	CINFO="\033[1;96m" # light blue
	CDEBUG="\033[1;94m" # blue
	CNORMAL="\033[0;39m" # default system console color
	CDONE="\033[1;32m" # green
	CPASS="\033[1;32m" # green
	CFAIL="\033[1;31m" # red
	CCMD="\033[1;35m" # pink
fi

msgdie() { printf "${CERROR}E: $1${CNORMAL}\n" >&2; exit 1; }
msgwarn() { printf "${CWARNING}W: $1${CNORMAL}\n" >&2; }
msgmsg() { printf "${CMSG}$1${CNORMAL}\n"; }
msginfo() { printf "${CINFO}I: $1${CNORMAL}\n"; }
msgdebug() { printf "${CDEBUG}D: $1${CNORMAL}\n"; }
msgdone() { printf "${CDONE}DONE${CNORMAL}\n"; }
msgnwarn() { printf "${CWARNING}W: $1${CNORMAL}" >&2; }
msgnmsg() { printf "${CMSG}$1${CNORMAL}"; }
msgninfo() { printf "${CINFO}I: $1${CNORMAL}"; }
msgndebug() { printf "${CDEBUG}D: $1${CNORMAL}"; }
msgtest() {
	while [ $# -gt 0 ]; do
		printf "${CINFO}%s${CCMD} %s${CNORMAL} " "$1" "$(sed -e 's#^apt\([cgfs]\)#apt-\1#' <<<"${2-}")"
		shift
		if [ $# -gt 0 ]; then
			shift
		else
			break
		fi
	done
	printf "${CINFO}…${CNORMAL} "
}
msgpass() { printf "${CPASS}PASS${CNORMAL}\n"; }
msgskip() { printf "${CWARNING}SKIP${CNORMAL}\n" >&2; }
msgfail() {
	if [ $# -gt 0 ]; then printf "${CFAIL}FAIL: $*${CNORMAL}\n" >&2;
	else printf "${CFAIL}FAIL${CNORMAL}\n" >&2; fi
	one_more_failure
}

# enable / disable Debugging
if [ $MSGLEVEL -le 0 ]; then
	# Although this override never happens with nonnegative MSGLEVEL, let's not
	# change the semantics: this msg*() function doesn't just print a message.
	msgdie() { exit 1; }
fi
if [ $MSGLEVEL -le 1 ]; then
	msgwarn() { true; }
	msgnwarn() { true; }
fi
if [ $MSGLEVEL -le 2 ]; then
	msgmsg() { true; }
	msgnmsg() { true; }
	msgtest() { true; }
	msgpass() { printf " ${CPASS}P${CNORMAL}"; }
	msgskip() { printf " ${CWARNING}S${CNORMAL}" >&2; }
	if [ -n "$CFAIL" ]; then
		msgfail() { printf " ${CFAIL}FAIL${CNORMAL}" >&2; one_more_failure; }
	else
		msgfail() { printf ' ###FAILED###' >&2; one_more_failure; }
	fi
fi
if [ $MSGLEVEL -le 3 ]; then
	msginfo() { true; }
	msgninfo() { true; }
fi
if [ $MSGLEVEL -le 4 ]; then
	msgdebug() { true; }
	msgndebug() { true; }
fi
msgdone() {
	if [ "$1" = 'debug' -a $MSGLEVEL -le 4 ] ||
	   [ "$1" = 'info' -a $MSGLEVEL -le 3 ] ||
	   [ "$1" = 'msg' -a $MSGLEVEL -le 2 ] ||
	   [ "$1" = 'warn' -a $MSGLEVEL -le 1 ] ||
	   [ "$1" = 'die' -a $MSGLEVEL -le 0 ]; then
		true;
	else
		printf "${CDONE}DONE${CNORMAL}\n";
	fi
}
getaptconfig() {
	if [ -f ./aptconfig.conf ]; then
            echo './aptconfig.conf'
	elif [ -f ../aptconfig.conf ]; then
            echo '../aptconfig.conf'
        fi
}
runapt() {
	msgdebug "CWD: $PWD"
	msgdebug "Executing: APT_CONFIG=$(getaptconfig) ${CCMD}$*${CDEBUG} "
	local CMD="$1"
	shift
	APT_CONFIG="$(getaptconfig)" $CMD "$@"
}
aptconfig() { runapt apt-config "$@"; }
aptcache() { runapt apt-cache "$@"; }
aptcdrom() { runapt apt-cdrom "$@"; }
aptget() { runapt apt-get "$@"; }
aptmark() { runapt apt-mark "$@"; }


exitwithstatus() {
        # error if we about to overflow, but ...
        #   "255 failures ought to be enough for everybody"
        if [ $EXIT_CODE -gt 254 ]; then
            msgdie "Total failure count $EXIT_CODE too big"
        fi
		if [ $EXIT_CODE -gt 0 ]; then
			exit $((EXIT_CODE <= 254 ? EXIT_CODE : 254));
		elif [ $XFAILED -gt 0 ]; then
			exit 255
		else
			exit 0
		fi
}

shellsetedetector() {
	local exit_status=$?
	if [ "$exit_status" != '0' ]; then
		printf >&2 "${CERROR}E: Looks like the testcases ended prematurely with exitcode: ${exit_status}${CNORMAL}\n"
		if [ "$EXIT_CODE" = '0' ]; then
			EXIT_CODE="$exit_status"
		fi
	fi
}

CURRENTTRAP=
addtrap() {
	if [ "$1" = 'prefix' ]; then
		CURRENTTRAP="$2 $CURRENTTRAP"
	else
		CURRENTTRAP="$CURRENTTRAP $1"
	fi
	trap "shellsetedetector; $CURRENTTRAP exitwithstatus;" 0 HUP INT QUIT ILL ABRT FPE SEGV PIPE TERM
}

setupenvironment() {
	TESTDIRECTORY=$(readlink -f $(dirname $0))
	addtrap '' # unconditionally set up our basic traps

	if [ -n "$APT_TEST_WORKINGDIRECTORY" ]; then
		TMPWORKINGDIRECTORY="$APT_TEST_WORKINGDIRECTORY"
	else
		TMPWORKINGDIRECTORY=$(mktemp -d)
		addtrap "cd /; rm -rf $TMPWORKINGDIRECTORY;"
	fi

	msgninfo "Preparing environment for ${CCMD}$(basename $0)${CINFO} in ${TMPWORKINGDIRECTORY}… "

	cd $TMPWORKINGDIRECTORY
	mkdir rootdir aptarchive keys
	cd rootdir
	mkdir -p \
		  etc/apt/apt.conf.d etc/apt/sources.list.d \
		  etc/apt/trusted.gpg.d etc/apt/preferences.d
	mkdir -p var/cache var/lib/apt var/log tmp
	mkdir -p var/lib/rpm
	mkdir -p var/lib/apt/lists/partial var/cache/apt/archives/partial
	cd ..

	{
		echo "Dir \"${TMPWORKINGDIRECTORY}/rootdir\";"
		echo 'Debug::NoLocking "true";'
		echo "Dir::Etc::sourcelist \"${TMPWORKINGDIRECTORY}/rootdir/etc/apt/sources.list\";"

		if [ -n "$METHODSDIR" ] ; then
			echo "Dir::Bin::methods \"$METHODSDIR\";"
		fi
	} > aptconfig.conf

	cat > rootdir/etc/apt/pkgpriorities << END
Important:
  basesystem
Required:
  apt
  systemd-sysvinit
  sysvinit
  openssh-server
Standard:
  postfix
END

	cat > rootdir/etc/apt/sources.list << END
rpm file://$TMPWORKINGDIRECTORY/usr/src/RPM/REPO $APT_TEST_USED_ARCH apt-tests
rpm file://$TMPWORKINGDIRECTORY/usr/src/RPM/REPO noarch apt-tests
END

	# cleanup the environment a bit
	export PATH="${PATH}:/usr/local/sbin:/usr/sbin:/sbin"
	export LC_ALL=C.UTF-8
	unset LANGUAGE APT_CONFIG
	unset GREP_OPTIONS

	# Initialize rpmdb
	rpmdb --dbpath="$TMPWORKINGDIRECTORY/var/lib/rpm" --initdb

	# setup rpm dbpath
	echo "RPM::DBPath \"$TMPWORKINGDIRECTORY/var/lib/rpm\";" \
		 > rootdir/etc/apt/apt.conf.d/99rpmdbpath.conf

	msgdone 'info'
}

# The arch (the machine arch) as detected by rpm or apt
# (and as expected to appear in the APT conf by default).
#
# * `uname -m` gives the base value.
# * rpm-build has its own way to determine the arch, which refines `uname -m`.
#   See: rpmbuild --eval %_arch 2>/dev/null ||:
#   (Packages are built by default for this arch, i.e.,
#   when there is no explicit --target.)
# * rpm has its own way to determine the arch (with more incompatible refinements
#   on ARM compared to rpm-build).
# * APT has its own simplistic way to determine the arch based on `uname -m`.
#
# FIXME: APT should probably use the same value as rpm for APT::Architecture.
# FIXME: rpmbuild's and rpm's ways need to be synchronized, particularly on ARM.
if [ -z "$APT_TEST_DEFAULT_ARCH" ]; then
	APT_TEST_DEFAULT_ARCH="$(uname -m)"
fi

# The arch used for the built packages, repos, etc.
# (May be forced by $APT_TEST_TARGET together with --target.)
if [ -n "$APT_TEST_TARGET" ]; then
	# set by force
	APT_TEST_USED_ARCH="$APT_TEST_TARGET"
else
	# just set it to an appropriate value, if not set by force
	APT_TEST_USED_ARCH="$APT_TEST_DEFAULT_ARCH"
fi

buildpackage() {
	local NAME="$1"

	local target_opt=
	if [ -n "$APT_TEST_TARGET" ]; then
		target_opt=--target="$APT_TEST_TARGET"
	fi

	msgmsg "Building package: ${NAME}"
	HOME="$TMPWORKINGDIRECTORY" rpmbuild \
		--define 'EVR %{?epoch:%epoch:}%{version}-%{release}' \
		--define 'packager test@example.net' \
		--define="_usr $TMPWORKINGDIRECTORY/usr" \
		--root="$TMPWORKINGDIRECTORY" \
		$target_opt \
		-ba "${TESTDIRECTORY}/specs/${NAME}.spec" \
		1>/dev/null
}

builtpackagefile() {
	local -r NAME="$1"

	. "${TESTDIRECTORY}/specs/${NAME}.metainfo"
	# To type less in *.metainfo, assume that the spec's filename coincides with
	# the package's name by default:
	if [ -z "${name-}" ]; then
		name="$NAME"
	fi
	# If arch is not specified in the spec, we know what was given as --target.
	if [ -z "${arch-}" ]; then
		arch="$APT_TEST_USED_ARCH"
	fi

	echo "$TMPWORKINGDIRECTORY/usr/src/RPM/RPMS/${arch}/${name}-${version}-${release}.${arch}.rpm"
}

builtpackagearch() {
	local -r NAME="$1"

	. "${TESTDIRECTORY}/specs/${NAME}.metainfo"
	# If arch is not specified in the spec, we know what was given as --target.
	if [ -z "${arch-}" ]; then
		arch="$APT_TEST_USED_ARCH"
	fi

	echo "${arch}"
}

builtpackageversion() {
	local -r NAME="$1"

	. "${TESTDIRECTORY}/specs/${NAME}.metainfo"

	echo "${version}-${release}"
}

installpackage() {
	local NAME="$1"

	local PKGFILE="$(builtpackagefile "$NAME")"

	msgmsg "Installing package via rpm: $(basename "$PKGFILE")"
	rpm --dbpath="$TMPWORKINGDIRECTORY/var/lib/rpm" \
		--nodeps \
		-i "$PKGFILE" \
		1>/dev/null
}

aptgetinstallpackage() {
	local NAME="$1"

	local PKGFILE="$(builtpackagefile "$NAME")"

	msgmsg "Installing package via apt-get: $(basename "$PKGFILE")"
	aptget install "$PKGFILE" \
		   1>/dev/null
}

checkdiff() {
	local DIFFTEXT="$(command diff -u "$@" | sed -e '/^---/ d' -e '/^+++/ d' -e '/^@@/ d')"
	if [ -n "$DIFFTEXT" ]; then
		echo >&2
		echo >&2 "$DIFFTEXT"
		return 1
	else
		return 0
	fi
}

testfileequal() {
	local FILE="$1"
	shift
	msgtest 'Test for correctness of file' "$FILE"
	if [ -z "$*" ]; then
		echo -n '' | checkdiff $FILE - && msgpass || msgfail
	else
		echo "$*" | checkdiff $FILE - && msgpass || msgfail
	fi
}

testempty() {
	msgtest 'Test for no output of' "$*"
	local COMPAREFILE="${TMPWORKINGDIRECTORY}/rootdir/tmp/testempty.comparefile"
	if $* >$COMPAREFILE 2>&1 && test ! -s $COMPAREFILE; then
		msgpass
	else
		cat $COMPAREFILE
		msgfail
	fi
}

testequal() {
	local MSG='Test of equality of'
	if [ "$1" = '--nomsg' ]; then
		MSG=''
		shift
	fi

	local COMPAREFILE="${TMPWORKINGDIRECTORY}/rootdir/tmp/testequal.comparefile"
	echo "$1" > $COMPAREFILE
	shift

	if [ -n "$MSG" ]; then
		msgtest "$MSG" "$*"
	fi
	"$@" 2>&1 | checkdiff $COMPAREFILE - && msgpass || msgfail
}

testregexmatch() {
	local MSG='Test of regex match of'
	if [ "$1" = '--nomsg' ]; then
		MSG=''
		shift
	fi

	local COMPAREMSG="$1"
	shift

	if [ -n "$MSG" ]; then
		msgtest "$MSG" "$*"
	fi

	local COMPAREFILE="${TMPWORKINGDIRECTORY}/rootdir/tmp/testregexmatch.comparefile"
	local RESULTFILE="${TMPWORKINGDIRECTORY}/rootdir/tmp/testregexmatch.resultfile"

	echo "^$COMPAREMSG\$" > $COMPAREFILE
	set +e
	"$@" &> $RESULTFILE
	set -e

	if [[ "$(cat $RESULTFILE)" =~ $(cat $COMPAREFILE) ]] ; then
		msgpass
	else
		checkdiff $COMPAREFILE $RESULTFILE || true
		msgfail
	fi
}

skiplines() {
	local count="$1"
	shift

	"$@" 2>&1 | tail +"$count"
}

testequalor2() {
	local COMPAREFILE1="${TMPWORKINGDIRECTORY}/rootdir/tmp/testequalor2.comparefile1"
	local COMPAREFILE2="${TMPWORKINGDIRECTORY}/rootdir/tmp/testequalor2.comparefile2"
	local COMPAREAGAINST="${TMPWORKINGDIRECTORY}/rootdir/tmp/testequalor2.compareagainst"
	echo "$1" > $COMPAREFILE1
	echo "$2" > $COMPAREFILE2
	shift 2
	msgtest 'Test for equality OR of' "$*"
	$* >$COMPAREAGAINST 2>&1 || true
	if checkdiff $COMPAREFILE1 $COMPAREAGAINST >/dev/null 2>&1 || \
		checkdiff $COMPAREFILE2 $COMPAREAGAINST >/dev/null 2>&1
	then
		msgpass
	else
		echo -ne "\n${CINFO}Diff against OR 1${CNORMAL}"
		checkdiff $COMPAREFILE1 $COMPAREAGAINST || true
		echo -n "${CINFO}Diff against OR 2${CNORMAL}"
		checkdiff $COMPAREFILE2 $COMPAREAGAINST || true
		msgfail
	fi
}

testshowvirtual() {
	local VIRTUAL="N: Can't select versions from package '$1' as it is purely virtual"
	local PACKAGE="$1"
	shift
	while [ -n "$1" ]; do
		VIRTUAL="${VIRTUAL}
N: Can't select versions from package '$1' as it is purely virtual"
		PACKAGE="${PACKAGE} $1"
		shift
	done
	msgtest 'Test for virtual packages' "apt-cache show $PACKAGE"
	VIRTUAL="${VIRTUAL}
N: No packages found"
	local COMPAREFILE="${TMPWORKINGDIRECTORY}/rootdir/tmp/testshowvirtual.comparefile"
	aptcache show -q=0 $PACKAGE 2>&1 | checkdiff $COMPAREFILE - &&
		msgpass || msgfail
}

testnopackage() {
	msgtest 'Test for non-existent packages' "apt-cache show $*"
	local SHOWPKG="$(aptcache show "$@" 2>&1 | grep '^Package: ')"
	if [ -n "$SHOWPKG" ]; then
		echo >&2
		echo >&2 "$SHOWPKG"
		msgfail
	else
		msgpass
	fi
}

testpkginstalled() {
	msgtest 'Test that package(s) are installed with' "rpm -q $*"

	local result=0

	set +e
	rpm --dbpath="$TMPWORKINGDIRECTORY/var/lib/rpm" -q "$@" >/dev/null
	result=$?
	set -e

	if [ $result -eq 0 ] ; then
		msgpass
	else
		msgfail
	fi
}

getpackageversion() {
	local result=

	set +e
	result=$(rpm --dbpath="$TMPWORKINGDIRECTORY/var/lib/rpm" \
				 -q --qf '%{EVR}\n' "$@" \
				 2>/dev/null)
	set -e

	echo $result
}

testpkgnotinstalled() {
	msgtest 'Test that package(s) are not installed with' "rpm -q $*"

	local result=0

	set +e
	rpm --dbpath="$TMPWORKINGDIRECTORY/var/lib/rpm" -q "$@" >&2 2>/dev/null
	result=$?
	set -e

	if [ $result -ne 0 ] ; then
		msgpass
	else
		msgfail
	fi
}

testsuccess() {
	if [ "$1" = '--nomsg' ]; then
		shift
	else
		msgtest 'Test for successful execution of' "$*"
	fi
	local OUTPUT="${TMPWORKINGDIRECTORY}/rootdir/tmp/testsuccess.output"
	if "$@" >${OUTPUT} 2>&1; then
		msgpass
	else
		echo >&2
		cat >&2 $OUTPUT
		msgfail
	fi
}

testfailure() {
	if [ "$1" = '--nomsg' ]; then
		shift
	else
		msgtest 'Test for failure in execution of' "$*"
	fi
	local OUTPUT="${TMPWORKINGDIRECTORY}/rootdir/tmp/testfailure.output"
	if $@ >${OUTPUT} 2>&1; then
		echo >&2
		cat >&2 $OUTPUT
		msgfail
	else
		msgpass
	fi
}

generaterepository() {
	local ORIG_DIR="$1"
	local REPO_DIR="$2"
	local REPO_DATE="${3-}"

	local label="$GB_REPO_LABEL"
	if [ -z "$label" ]; then
		label="apt-tests"
	fi
	local description="$GB_REPO_DESCRIPTION"
	if [ -z "$description" ]; then
		description="ALT Linux $label"
	fi
	local date_s="$(date +%s)"
	local arch="$APT_TEST_USED_ARCH"
	local comps="${label}"

	if [ -n "$REPO_DATE" ] ; then
		date_s="$REPO_DATE"
	fi

	local archive="$GB_REPO_ARCHIVE"
	if [ -z "$archive" ]; then
		archive="$description"
	fi
	local codename="$GB_REPO_CODENAME"
	if [ -z "$codename" ]; then
		codename="$date_s"
	fi
	local origin="$GB_REPO_ORIGIN"
	if [ -z "$origin" ]; then
		origin="ALT Linux Team"
	fi
	local suite="$GB_REPO_SUITE"
	if [ -z "$suite" ]; then
		suite="$label"
	fi
	local version="$GB_REPO_VERSION"
	if [ -z "$version" ]; then
		version="$date_s"
	fi

	rm -rf "$REPO_DIR"
	for dir in ${arch} noarch ; do
		mkdir -p "${REPO_DIR}/${dir}/RPMS.${label}"
		mkdir -p "${REPO_DIR}/${dir}/base"
		stat "${ORIG_DIR}/${dir}/"*.rpm &>/dev/null &&
			cp "${ORIG_DIR}/${dir}/"*.rpm "${REPO_DIR}/${dir}/RPMS.${label}"/
	done

	mkdir -p "${TMPWORKINGDIRECTORY}/cache"

	for dir in ${arch} noarch ; do
		genbasedir \
			--cachedir="${TMPWORKINGDIRECTORY}/cache" \
			--architecture="$dir" \
			--architectures="$dir" \
			--archive="$archive" \
			--codename="$codename" \
			--description="$description" \
			--label="$label" \
			--origin="$origin" \
			--suite="$suite" \
			--version="$version" \
			--topdir="$REPO_DIR" \
			--changelog-since='@1' \
			--flat --no-oldhashfile --no-bz2 --no-xz --mapi \
			$dir $comps

		if [ -n "$REPO_DATE" ] ; then
			touch -t $(date --date=@${REPO_DATE} '+%Y%m%d%H%M.%S') \
				  "${REPO_DIR}/${dir}/base/"*
		fi
	done
}
