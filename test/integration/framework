#!/bin/sh -X # no runnable script, just for editors
# set -eu is assumed.
# (Note that in ALT /bin/sh is a bash with a few features turned off.)
# (TODO: make sure that ALT's /bin/sh is enough;
# use the lightweight /bin/sh in the actual test scripts.)
#
# At least the syntax in nginxstart() requires bash >= 4 (&>>).

# TESTDIR is usually set in all the testscripts sourcing framework.
. $TESTDIR/framework-without-repo

aptcdrom() { runapt apt-cdrom "${CDROM_OPTS[@]}" "$@"; }

generaterepository() {
	local orig_dir="$1"
	local repo_dir="$2"
	local repo_date="${3-}"

	local label="$GB_REPO_LABEL"
	if [ -z "$label" ]; then
		label="apt-tests"
	fi
	local description="$GB_REPO_DESCRIPTION"
	if [ -z "$description" ]; then
		description="ALT Linux $label"
	fi
	local date_s="$(date +%s)"
	local arch="$APT_TEST_USED_ARCH"
	local comps="${label}"

	if [ -n "$repo_date" ] ; then
		date_s="$repo_date"
	fi

	local archive="$GB_REPO_ARCHIVE"
	if [ -z "$archive" ]; then
		archive="$description"
	fi
	local codename="$GB_REPO_CODENAME"
	if [ -z "$codename" ]; then
		codename="$date_s"
	fi
	local origin="$GB_REPO_ORIGIN"
	if [ -z "$origin" ]; then
		origin="ALT Linux Team"
	fi
	local suite="$GB_REPO_SUITE"
	if [ -z "$suite" ]; then
		suite="$label"
	fi
	local version="$GB_REPO_VERSION"
	if [ -z "$version" ]; then
		version="$date_s"
	fi

	# The compression opts can be forced from the environment.
	local compression_opts="$APT_TEST_BASEDIR_COMPRESSION_OPTS"
	if [ -z "$compression_opts" ]; then
		# By default, choose minimal required compressions
		# for the chosen method to work without errors.
		# (FIXME: fix APT so that the used compression doesn't matter!)
		case "$APT_TEST_METHOD" in

			http*) compression_opts='--no-bz2 --xz'
			   ;;

			cdrom*) compression_opts='--bz2 --no-xz'
			   ;;

			*) compression_opts='--no-bz2 --no-xz'
			   ;;

		esac
	fi

	rm -rf "$repo_dir"
	for dir in ${arch} noarch ; do
		mkdir -p "${repo_dir}/${dir}/RPMS.${label}"
		mkdir -p "${repo_dir}/${dir}/base"
		stat "${orig_dir}/${dir}/"*.rpm &>/dev/null &&
			cp "${orig_dir}/${dir}/"*.rpm "${repo_dir}/${dir}/RPMS.${label}"/
	done

	mkdir -p "${TMPWORKINGDIRECTORY}/cache"

	for dir in ${arch} noarch ; do
		genbasedir \
			--cachedir="${TMPWORKINGDIRECTORY}/cache" \
			--architecture="$dir" \
			--architectures="$dir" \
			--archive="$archive" \
			--codename="$codename" \
			--description="$description" \
			--label="$label" \
			--origin="$origin" \
			--suite="$suite" \
			--version="$version" \
			--topdir="$repo_dir" \
			--changelog-since='@1' \
			--flat --no-oldhashfile $compression_opts --mapi \
			$dir $comps

		if [ -n "$repo_date" ] ; then
			touch -t $(date --date=@${repo_date} '+%Y%m%d%H%M.%S') \
				  "${repo_dir}/${dir}/base/"*
		fi
	done
}

generaterepository_and_switch_sources() {
	local -r ORIG_DIR="$1"
	local REPO_DIR # will be set depending on the method
	local -r REPO_DATE="${2-}"

	case "$APT_TEST_METHOD" in

		file)
			REPO_DIR="$TMPWORKINGDIRECTORY/usr/src/RPM/REPO"

			generaterepository "$ORIG_DIR" "$REPO_DIR" "$REPO_DATE"

			# overwrite old sources.list
			cat >| rootdir/etc/apt/sources.list <<- END
				rpm $APT_TEST_METHOD://$REPO_DIR $APT_TEST_USED_ARCH apt-tests
				rpm $APT_TEST_METHOD://$REPO_DIR noarch apt-tests
			END
			;;

		http|https|https_invalid_cert_hostname)
			REPO_DIR="$TMPWORKINGDIRECTORY/nginx/repo"

			case "$APT_TEST_METHOD" in
				http)
					nginxsetuphttp
					;;
				https*)
					nginxsetuphttps

					# generate key
					case "$APT_TEST_METHOD" in
						https_invalid_cert_hostname)
							local -r cert_hostname=wronghost
							;;
						*)
							local -r cert_hostname=localhost
							;;
					esac
					openssl req -x509 \
						-newkey rsa:4096 \
						-keyout $NGINX_KEY \
						-out $TMPWORKINGDIRECTORY/nginx/cert.crt \
						-nodes \
						-days 365 \
						-subj "/CN=$cert_hostname" \
					    &>/dev/null

					# add key to apt's config. Also pin the key
					cat > $TMPWORKINGDIRECTORY/rootdir/etc/apt/apt.conf.d/80https.conf <<- END
					Acquire::https::CaInfo	"$TMPWORKINGDIRECTORY/nginx/cert.crt";
					END

					cat > $TMPWORKINGDIRECTORY/rootdir/etc/apt/apt.conf.d/81https-pinning.conf <<- END
					Acquire::https::PinnedCert	"$TMPWORKINGDIRECTORY/nginx/cert.crt";
					END
					;;
			esac

			generaterepository "$ORIG_DIR" "$REPO_DIR" "$REPO_DATE"

			# overwrite old sources.list
			cat >| rootdir/etc/apt/sources.list <<- END
				rpm ${APT_TEST_METHOD%%_*}://localhost:$((8080+PARALLEL_SLOT))/ $APT_TEST_USED_ARCH apt-tests
				rpm ${APT_TEST_METHOD%%_*}://localhost:$((8080+PARALLEL_SLOT))/ noarch apt-tests
			END

			nginxrestart
			;;

		cdrom|cdrom_missing_release)

			generaterepository "$ORIG_DIR" "$MOCKUP_CDROM_STORAGE" "$REPO_DATE"
			mkdir "$MOCKUP_CDROM_STORAGE"/.disk
			# trailing whitespace here might be misinterpreted
			echo "Distribution $REPO_DATE Disk" >"$MOCKUP_CDROM_STORAGE"/.disk/info

			# DEBUG: Let's have an idea of the FS tree there:
			#ls -laR "$MOCKUP_CDROM_STORAGE"

			case "$APT_TEST_METHOD" in
				cdrom_missing_release)
					find "$MOCKUP_CDROM_STORAGE"/*/base -name 'release*' -print -delete
					;;
			esac

			# overwrite old sources.list
			echo >| rootdir/etc/apt/sources.list
			aptcdrom add <<<$'\n'
			;;

		*)
			msgdie 'unknown $APT_TEST_METHOD'
			;;

	esac
}

# Output/effects:
# * global vars representing the actual configuration of the server
#   (convenient for use in other scripts):
#   NGINX_PIDFILE
# * the server configured, ready for nginxrestart()
nginxsetuphttp() {
	mkdir -p $TMPWORKINGDIRECTORY/nginx
	mkdir -p $TMPWORKINGDIRECTORY/nginx/tmp

	NGINX_PIDFILE=$TMPWORKINGDIRECTORY/nginx/nginx.pid

	cat >| $TMPWORKINGDIRECTORY/nginx/nginx.conf << ENDCONFIG
error_log stderr;
worker_processes 1;
pid $NGINX_PIDFILE;

events {
	worker_connections  1024;
}

http {
	client_body_temp_path $TMPWORKINGDIRECTORY/nginx/tmp/client_body;
	fastcgi_temp_path $TMPWORKINGDIRECTORY/nginx/tmp/fastcgi_temp;
	proxy_temp_path $TMPWORKINGDIRECTORY/nginx/tmp/proxy_temp;
	scgi_temp_path $TMPWORKINGDIRECTORY/nginx/tmp/scgi_temp;
	uwsgi_temp_path $TMPWORKINGDIRECTORY/nginx/tmp/uwsgi_temp;

	include             /etc/nginx/mime.types;
	default_type        application/octet-stream;

	sendfile off;

	keepalive_timeout   65;

	ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
	ssl_prefer_server_ciphers on;
	access_log stderr;
	error_log stderr;

	server {
		listen $((8080+PARALLEL_SLOT));
		server_name localhost localhost.localdomain;

		location / {
			root $TMPWORKINGDIRECTORY/nginx/repo;
			autoindex on;
		}
	}
}
ENDCONFIG
}

# Output/effects:
# * global vars representing the actual configuration of the server
#   (convenient for use in other scripts):
#   NGINX_KEY, NGINX_PIDFILE
# * the server configured, ready for nginxrestart() (except for the key)
nginxsetuphttps() {
	mkdir -p $TMPWORKINGDIRECTORY/nginx
	mkdir -p $TMPWORKINGDIRECTORY/nginx/tmp

	NGINX_KEY=$TMPWORKINGDIRECTORY/nginx/cert.key
	NGINX_PIDFILE=$TMPWORKINGDIRECTORY/nginx/nginx.pid

	cat >| $TMPWORKINGDIRECTORY/nginx/nginx.conf << ENDCONFIG
error_log stderr;
worker_processes 1;
pid $NGINX_PIDFILE;

events {
	worker_connections  1024;
}

http {
	client_body_temp_path $TMPWORKINGDIRECTORY/nginx/tmp/client_body;
	fastcgi_temp_path $TMPWORKINGDIRECTORY/nginx/tmp/fastcgi_temp;
	proxy_temp_path $TMPWORKINGDIRECTORY/nginx/tmp/proxy_temp;
	scgi_temp_path $TMPWORKINGDIRECTORY/nginx/tmp/scgi_temp;
	uwsgi_temp_path $TMPWORKINGDIRECTORY/nginx/tmp/uwsgi_temp;

	include             /etc/nginx/mime.types;
	default_type        application/octet-stream;

	sendfile off;

	keepalive_timeout   65;

	ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
	ssl_prefer_server_ciphers on;
	access_log stderr;
	error_log stderr;

	server {
		listen $((8080+PARALLEL_SLOT)) ssl;
		server_name localhost localhost.localdomain;

		ssl_certificate	$TMPWORKINGDIRECTORY/nginx/cert.crt;
		ssl_certificate_key	$NGINX_KEY;

		ssl_session_cache	builtin:1000	shared:SSL:10m;
		ssl_protocols TLSv1.2;
		ssl_ciphers HIGH:!aNULL:!eNULL:!EXPORT:!CAMELLIA:!DES:!MD5:!PSK:!RC4;
		ssl_prefer_server_ciphers on;

		location / {
			root $TMPWORKINGDIRECTORY/nginx/repo;
			autoindex on;
		}
	}
}
ENDCONFIG
}

wait_for_file() {
	# The message 'Waiting...' is intentionally printed regardless of $MSGLEVEL;
	# otherwise it would be difficult to see why the process is hanging;
	# it can appear only in extra-ordinary situations (under heavy load).
	[ -s "$1" ] ||
		printf >&2 'Waiting for %s\n' "$1" &&
		while ! [ -s "$1" ]; do
			sleep 0.5
		done
}

nginxrestart() {
	local -r NGINXLOG=$TMPWORKINGDIRECTORY/nginx/process-stderr.log

	! [ -s "$NGINX_PIDFILE" ] || {
		echo 'Stopping nginx with a signal (before a restart).'
		kill -TERM "$(cat "$NGINX_PIDFILE")"
	} &>>"$NGINXLOG"
	rm -f "$NGINX_PIDFILE"

	# The wait_for_file workaround would not be needed if nginx fully conformed
	# to the "traditional UNIX forking daemon" behavior described
	# in systemd.service(5); unfortunately for us, the upstream hasn't "fixed"
	# this race[1], although a patch for synchronizing the exit of the parent
	# with the creation of the pidfile is available[2].
	# [1]: https://trac.nginx.org/nginx/ticket/1897
	# [2]: http://mailman.nginx.org/pipermail/nginx-ru/2017-November/060628.html
	/usr/sbin/nginx -c $TMPWORKINGDIRECTORY/nginx/nginx.conf -p $TMPWORKINGDIRECTORY &>>"$NGINXLOG" &&
		wait_for_file "$NGINX_PIDFILE" &&
		local -r NGINXPID="$(cat "$NGINX_PIDFILE" 2>>"$NGINXLOG")" &&
		[ -n "$NGINXPID" ] ||
			{ { echo NGINXLOG:; cat "$NGINXLOG"; } >&2 ||:
			  msgdie 'nginx failed to start normally'
			}

	addtrap 'prefix' \
			'kill -TERM %q ||:; [ "$EXIT_CODE" = 0 ] || if [ -e %q ]; then echo NGINXLOG:; cat %q ||:; fi;' \
			"$NGINXPID" \
			"$NGINXLOG"
}
